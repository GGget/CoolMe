首先js是单线程
异步：
##预期是每隔一秒依次输出0，1，2，3，4##
代码:
for(var i=0;i<5;i++){

	
setTimeout(function(){

		console.log(i);

   	 },1000)

}
实际输出结果是：进行了5次循环，1秒后输出5个“5”。
原因：详细过程是先依次进行5次循环，每次循序中的定时器因为一秒后运行，所以跳过定时器，给定时器了一个即时i，然后继续进行下一个循环。然后完成5次循环，最后循环中i=5不符合条件i<5.循环结束。然后再开始执行定时器，定时器是异步函数，会同时开始计时，一秒后五个定时器都执行定时器里的函数function(){console.log(i);}此时的函数获取到i是for循环执行完之后的i，所以会输出5。
***************************************************************
##实现每隔一秒输出一个##
原因就是setTimeout获取到了即时的i=0，1，2，3，4但是无法传给里面的function(){}使用
代码：
for(var i=0;i<5;i++){

	
setTimeout(function(){

		console.log(i);

   	 },i*1000)

}
结果也是输出的5，但是是在从for结束后的0*1000，1*1000，2*1000，3*1000，4*1000 ms后再输出的，也就是每隔一秒输出一个5，因为setTimeout获取的是即时的i，不是结束后的i
***************************************************************
##实现依次输出##
如果想让function获取到即时的i,可以给function加自调用，将setTimeout的i实参赋值给function的形参,形参自定义，实参是i
代码：
for(var i=0;i<5;i++){

	
setTimeout(  (function(n){

		console.log(n);

   	 } )  ( i )  ,1000)

}
****************************************************************
输出的结果不是一行一个值，而是计数的形式输出一个值，这里异步函数就相当于是个多线程的函数，